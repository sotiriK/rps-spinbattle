{"version":3,"file":"static/js/83.e86d40de.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","../node_modules/pixi.js/src/rendering/renderers/types.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","import { maxRecommendedTextures } from '../../renderers/shared/texture/utils/maxRecommendedTextures';\n\nimport type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(maxRecommendedTextures())}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(maxRecommendedTextures())}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(maxRecommendedTextures())}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is layed out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\ninterface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\ninterface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\ninterface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            if (!gpuProgram)\n            {\n                // build out a dummy bind group..\n                groupMap = {};\n                groups = {\n                    99: new BindGroup(),\n                };\n\n                this._ownedBindGroups.push(groups[99]);\n\n                let bindTick = 0;\n\n                for (const i in resources)\n                {\n                    // Yes i know this is a little strange, but wil line up the shaders neatly\n                    // basically we want to be driven by how webGPU does things.\n                    // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                    nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                    groupMap[99] = groupMap[99] || {};\n                    groupMap[99][bindTick] = i;\n\n                    bindTick++;\n                }\n            }\n            else\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupMap = {};\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            groups = {};\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>'\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/* eslint-disable quote-props */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter weather or not you want to do somthing in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n"],"names":["addBits","srcParts","parts","name","i","part","toLocaleLowerCase","sanitisedPart","replace","push","concat","warn","findHooksRx","compileHooks","programSrc","_programSrc$match$map","_programSrc$match","match","map","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","arguments","length","undefined","results","fragment","header","mainInput","finalString","inValue","join","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","cacheMap","Object","create","bitCacheMap","Map","CACHE_UID","compileHighShader","_ref","bits","cacheId","generateCacheId","vertex","vertexFragments","shaderBit","filter","v","fragmentFragments","compiledVertex","index","mainStruct","indexOf","mainStart","mainEnd","value","extractVariableName","compiledCode","compileOutputs","compiledFragment","compileInputsAndOutputs","compileBits","compileHighShaderGl","_ref2","highFragment","has","set","get","a","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","source","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","maxRecommendedTextures","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","roundPixelsBit","roundPixelsBitGl","maxFragmentPrecision","getMaxFragmentPrecision","gl","getTestContext","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","options","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","shaderName","insertVersion","programCache","_GlProgram","constructor","defaultOptions","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","keys","processKey","processOptions","this","_key","createIdFromString","destroy","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","key","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractStructAndGroups","wgsl","_wgsl$match","_wgsl$match$map$filte","_wgsl$match2","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","item","group","parseInt","binding","isUniform","type","structs","struct","members","reduce","acc","member","name2","split","trim","some","ShaderStage","ShaderStage2","_this$layout$","_this$layout$2","_layoutKey","layout","gpuLayout","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","add","removeStructAndGroupDuplicates","generateLayoutHash","visibility","VERTEX","FRAGMENT","buffer","sampler","texture","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","_this$_attributeData","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","_WGSL_TO_VERTEX_TYPES","format","location","stride","getAttributeInfoFromFormat","offset","instance","start","extractAttributesFromGpuProgram","attributeFormatData","uint8x2","size","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","_attributeFormatData$","Shader","EventEmitter","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","Error","j","uniformName","groupData","data","BindGroup","bindTick","_resourceType","UniformGroup","setResource","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","defineProperty","getResource","destroyPrograms","_this$gpuProgram","_this$glProgram","emit","removeAllListeners","bindGroup","gpu","rest","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","Float32Array","_UniformGroup","uniformStructures","_touched","uid","_resourceId","isUniformGroup","_dirtyId","destroyed","uniforms","_uniformData$size","_uniformData$value","uniformData","ubo","isStatic","_signature","update","blendModeIds","normal","multiply","screen","overlay","erase","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","State","count","TexturePool","textureOptions","_poolKeyHash","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","label","getOptimalTexture","frameWidth","frameHeight","po2Width","Math","ceil","po2Height","nextPow2","pop","_resolution","frame","x","y","updateUvs","getSameSizeTexture","returnTexture","renderTexture","clear","destroyTextures","textures","idCounts","idHash","groupId","id","RendererType2","color32BitToUniform","abgr","alpha","BatchableSprite","vertexSize","indexSize","batcher","batch","roundPixels","renderable","groupBlendMode","packAttributes","float32View","uint32View","textureId","sprite","wt","groupTransform","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset"],"sourceRoot":""}