"use strict";(self.webpackChunkgame_dev_assessment=self.webpackChunkgame_dev_assessment||[]).push([[83],{9569:(t,e,n)=>{n.d(e,{I:()=>S,v:()=>C});var r=n(5920),o=n(7699),i=n(279);function s(t,e,n){if(t)for(const r in t){const o=e[r.toLocaleLowerCase()];if(o){let e=t[r];"header"===r&&(e=e.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),n&&o.push("//----".concat(n,"----//")),o.push(e)}else(0,i.R)("".concat(r," placement hook does not exist in shader"))}}const a=/\{\{(.*?)\}\}/g;function u(t){var e,n;const r={};return(null!==(e=null===(n=t.match(a))||void 0===n?void 0:n.map((t=>t.replace(/[{()}]/g,""))))&&void 0!==e?e:[]).forEach((t=>{r[t]=[]})),r}function c(t,e){let n;const r=/@in\s+([^;]+);/g;for(;null!==(n=r.exec(t));)e.push(n[1])}function l(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=[];c(e,r),t.forEach((t=>{t.header&&c(t.header,r)}));const o=r;n&&o.sort();const i=o.map(((t,e)=>"       @location(".concat(e,") ").concat(t,","))).join("\n");let s=e.replace(/@in\s+[^;]+;\s*/g,"");return s=s.replace("{{in}}","\n".concat(i,"\n")),s}function d(t,e){let n;const r=/@out\s+([^;]+);/g;for(;null!==(n=r.exec(t));)e.push(n[1])}function f(t,e){let n=t;for(const r in e){const t=e[r];n=t.join("\n").length?n.replace("{{".concat(r,"}}"),"//-----".concat(r," START-----//\n").concat(t.join("\n"),"\n//----").concat(r," FINISH----//")):n.replace("{{".concat(r,"}}"),"")}return n}const m=Object.create(null),h=new Map;let p=0;function g(t){let{template:e,bits:n}=t;const r=x(e,n);if(m[r])return m[r];const{vertex:o,fragment:i}=function(t,e){const n=e.map((t=>t.vertex)).filter((t=>!!t)),r=e.map((t=>t.fragment)).filter((t=>!!t));let o=l(n,t.vertex,!0);o=function(t,e){const n=[];d(e,n),t.forEach((t=>{t.header&&d(t.header,n)}));let r=0;const o=n.sort().map((t=>t.indexOf("builtin")>-1?t:"@location(".concat(r++,") ").concat(t))).join(",\n"),i=n.sort().map((t=>"       var ".concat(t.replace(/@.*?\s+/g,""),";"))).join("\n"),s="return VSOutput(\n                ".concat(n.sort().map((t=>" ".concat(function(t){const e=/\b(\w+)\s*:/g.exec(t);return e?e[1]:""}(t)))).join(",\n"),");");let a=e.replace(/@out\s+[^;]+;\s*/g,"");return a=a.replace("{{struct}}","\n".concat(o,"\n")),a=a.replace("{{start}}","\n".concat(i,"\n")),a=a.replace("{{return}}","\n".concat(s,"\n")),a}(n,o);const i=l(r,t.fragment,!0);return{vertex:o,fragment:i}}(e,n);return m[r]=b(o,i,n),m[r]}function v(t){let{template:e,bits:n}=t;const r=x(e,n);return m[r]||(m[r]=b(e.vertex,e.fragment,n)),m[r]}function x(t,e){return e.map((t=>(h.has(t)||h.set(t,p++),h.get(t)))).sort(((t,e)=>t-e)).join("-")+t.vertex+t.fragment}function b(t,e,n){const r=u(t),o=u(e);return n.forEach((t=>{s(t.vertex,r,t.name),s(t.fragment,o,t.name)})),{vertex:f(t,r),fragment:f(e,o)}}const y="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",P="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",_="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",w="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",M={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},T={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function C(t){let{bits:e,name:n}=t;const r=g({template:{fragment:P,vertex:y},bits:[M,...e]});return o.B.from({name:n,vertex:{source:r.vertex,entryPoint:"main"},fragment:{source:r.fragment,entryPoint:"main"}})}function S(t){let{bits:e,name:n}=t;return new r.M({name:n,...v({template:{vertex:_,fragment:w},bits:[T,...e]})})}},763:(t,e,n)=>{n.d(e,{F:()=>r,a:()=>o});const r={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},o={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},1193:(t,e,n)=>{n.d(e,{P:()=>l,_:()=>a});var r=n(2606);const o={};function i(t){const e=[];if(1===t)e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),e.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let n=0;for(let r=0;r<t;r++)e.push("@group(1) @binding(".concat(n++,") var textureSource").concat(r+1,": texture_2d<f32>;")),e.push("@group(1) @binding(".concat(n++,") var textureSampler").concat(r+1,": sampler;"))}return e.join("\n")}function s(t){const e=[];if(1===t)e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{e.push("switch vTextureId {");for(let n=0;n<t;n++)n===t-1?e.push("  default:{"):e.push("  case ".concat(n,":{")),e.push("      outColor = textureSampleGrad(textureSource".concat(n+1,", textureSampler").concat(n+1,", vUV, uvDx, uvDy);")),e.push("      break;}");e.push("}")}return e.join("\n")}function a(t){return o[t]||(o[t]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:"\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ".concat(i((0,r.c)()),"\n            "),main:"\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ".concat(s((0,r.c)()),"\n            ")}}),o[t]}const u={};function c(t){const e=[];for(let n=0;n<t;n++)n>0&&e.push("else"),n<t-1&&e.push("if(vTextureId < ".concat(n,".5)")),e.push("{"),e.push("\toutColor = texture(uTextures[".concat(n,"], vUV);")),e.push("}");return e.join("\n")}function l(t){return u[t]||(u[t]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:"\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[".concat(t,"];\n              \n            "),main:"\n    \n                ".concat(c((0,r.c)()),"\n            ")}}),u[t]}},454:(t,e,n)=>{n.d(e,{Ls:()=>r,_Q:()=>o,mA:()=>i});const r={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},o={...r,vertex:{...r.vertex,header:r.vertex.header.replace("group(1)","group(2)")}},i={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},4994:(t,e,n)=>{n.d(e,{b:()=>r,m:()=>o});const r={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}},o={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},5920:(t,e,n)=>{n.d(e,{M:()=>f});var r=n(801),o=n(87);let i;function s(){if(!i){i="mediump";const t=(0,o.W)();if(t&&t.getShaderPrecisionFormat){const e=t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT);i=e.precision?"highp":"mediump"}}return i}const a={},u={};const c={stripVersion:function(t,e){return e?t.replace("#version 300 es",""):t},ensurePrecision:function(t,e,n){const r=n?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if("precision"!==t.substring(0,9)){let o=n?e.requestedFragmentPrecision:e.requestedVertexPrecision;return"highp"===o&&"highp"!==r&&(o="mediump"),"precision ".concat(o," float;\n").concat(t)}return"highp"!==r&&"precision highp"===t.substring(0,15)?t.replace("precision highp","precision mediump"):t},addProgramDefines:function(t,e,n){return e?t:n?(t=t.replace("out vec4 finalColor;",""),"\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ".concat(t,"\n        ")):"\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ".concat(t,"\n        ")},setProgramName:function(t,e){let{name:n="pixi-program"}=e,r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];n=n.replace(/\s+/g,"-"),n+=r?"-fragment":"-vertex";const o=r?a:u;if(o[n]?(o[n]++,n+="-".concat(o[n])):o[n]=1,-1!==t.indexOf("#define SHADER_NAME"))return t;const i="#define SHADER_NAME ".concat(n);return"".concat(i,"\n").concat(t)},insertVersion:function(t,e){return e?"#version 300 es\n".concat(t):t}},l=Object.create(null),d=class t{constructor(e){const n=-1!==(e={...t.defaultOptions,...e}).fragment.indexOf("#version 300 es"),o={stripVersion:n,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:s()},setProgramName:{name:e.name},addProgramDefines:n,insertVersion:n};let i=e.fragment,a=e.vertex;Object.keys(c).forEach((t=>{const e=o[t];i=c[t](i,e,!0),a=c[t](a,e,!1)})),this.fragment=i,this.vertex=a,this._key=(0,r.X)("".concat(this.vertex,":").concat(this.fragment),"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(e){const n="".concat(e.vertex,":").concat(e.fragment);return l[n]||(l[n]=new t(e)),l[n]}};d.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let f=d},7699:(t,e,n)=>{n.d(e,{B:()=>c});var r=n(801),o=n(7393);const i={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function s(t){var e,n,r;const o=/@group\((\d+)\)/,i=/@binding\((\d+)\)/,s=/var(<[^>]+>)? (\w+)/,a=/:\s*(\w+)/,u=/(\w+)\s*:\s*([\w\<\>]+)/g,c=/struct\s+(\w+)/,l=null===(e=t.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g))||void 0===e?void 0:e.map((t=>({group:parseInt(t.match(o)[1],10),binding:parseInt(t.match(i)[1],10),name:t.match(s)[2],isUniform:"<uniform>"===t.match(s)[1],type:t.match(a)[1]})));if(!l)return{groups:[],structs:[]};const d=null!==(n=null===(r=t.match(/struct\s+(\w+)\s*{([^}]+)}/g))||void 0===r?void 0:r.map((t=>{const e=t.match(c)[1],n=t.match(u).reduce(((t,e)=>{const[n,r]=e.split(":");return t[n.trim()]=r.trim(),t}),{});return n?{name:e,members:n}:null})).filter((t=>{let{name:e}=t;return l.some((t=>t.type===e))})))&&void 0!==n?n:[];return{groups:l,structs:d}}var a=(t=>(t[t.VERTEX=1]="VERTEX",t[t.FRAGMENT=2]="FRAGMENT",t[t.COMPUTE=4]="COMPUTE",t))(a||{});const u=Object.create(null);class c{constructor(t){var e,n;this._layoutKey=0;const{fragment:r,vertex:o,layout:i,gpuLayout:u,name:c}=t;if(this.name=c,this.fragment=r,this.vertex=o,r.source===o.source){const t=s(r.source);this.structsAndGroups=t}else{const t=s(o.source),e=s(r.source);this.structsAndGroups=function(t,e){const n=new Set,r=new Set;return{structs:[...t.structs,...e.structs].filter((t=>!n.has(t.name)&&(n.add(t.name),!0))),groups:[...t.groups,...e.groups].filter((t=>{const e="".concat(t.name,"-").concat(t.binding);return!r.has(e)&&(r.add(e),!0)}))}}(t,e)}this.layout=null!==i&&void 0!==i?i:function(t){let{groups:e}=t;const n=[];for(let r=0;r<e.length;r++){const t=e[r];n[t.group]||(n[t.group]={}),n[t.group][t.name]=t.binding}return n}(this.structsAndGroups),this.gpuLayout=null!==u&&void 0!==u?u:function(t){let{groups:e}=t;const n=[];for(let r=0;r<e.length;r++){const t=e[r];n[t.group]||(n[t.group]=[]),t.isUniform?n[t.group].push({binding:t.binding,visibility:a.VERTEX|a.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===t.type?n[t.group].push({binding:t.binding,visibility:a.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===t.type&&n[t.group].push({binding:t.binding,visibility:a.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return n}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===(null===(e=this.layout[0])||void 0===e?void 0:e.globalUniforms)),this.autoAssignLocalUniforms=!(void 0===(null===(n=this.layout[1])||void 0===n?void 0:n.localUniforms)),this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,n=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=(0,r.X)(n,"program")}get attributeData(){var t;return null!==(t=this._attributeData)&&void 0!==t||(this._attributeData=function(t){let{source:e,entryPoint:n}=t;const r={},s=e.indexOf("fn ".concat(n));if(-1!==s){const t=e.indexOf("->",s);if(-1!==t){const n=e.substring(s,t),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let c;for(;null!==(c=u.exec(n));){var a;const t=null!==(a=i[c[3]])&&void 0!==a?a:"float32";r[c[2]]={location:parseInt(c[1],10),format:t,stride:(0,o.m)(t).stride,offset:0,instance:!1,start:0}}}}return r}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(t){const e="".concat(t.vertex.source,":").concat(t.fragment.source,":").concat(t.fragment.entryPoint,":").concat(t.vertex.entryPoint);return u[e]||(u[e]=new c(t)),u[e]}}},7393:(t,e,n)=>{n.d(e,{m:()=>o});const r={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function o(t){var e;return null!==(e=r[t])&&void 0!==e?e:r.float32}},3636:(t,e,n)=>{n.d(e,{M:()=>c});var r=n(8379),o=n(5920),i=n(2590),s=n(7699),a=n(6650),u=n(5222);class c extends r.A{constructor(t){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:n,groups:r,resources:o,compatibleRenderers:s,groupMap:c}=t;this.gpuProgram=e,this.glProgram=n,void 0===s&&(s=0,e&&(s|=a.W.WEBGPU),n&&(s|=a.W.WEBGL)),this.compatibleRenderers=s;const l={};if(o||r||(o={}),o&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&r&&!c)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&r&&c)for(const i in c)for(const t in c[i]){const e=c[i][t];l[e]={group:i,binding:t,name:e}}else if(e&&r&&!c){const t=e.structsAndGroups.groups;c={},t.forEach((t=>{c[t.group]=c[t.group]||{},c[t.group][t.binding]=t.name,l[t.name]=t}))}else if(o){if(e){const t=e.structsAndGroups.groups;c={},t.forEach((t=>{c[t.group]=c[t.group]||{},c[t.group][t.binding]=t.name,l[t.name]=t}))}else{c={},r={99:new i.T},this._ownedBindGroups.push(r[99]);let t=0;for(const e in o)l[e]={group:99,binding:t,name:e},c[99]=c[99]||{},c[99][t]=e,t++}r={};for(const t in o){const e=t;let n=o[t];n.source||n._resourceType||(n=new u.k(n));const s=l[e];s&&(r[s.group]||(r[s.group]=new i.T,this._ownedBindGroups.push(r[s.group])),r[s.group].setResource(n,s.binding))}}this.groups=r,this._uniformBindMap=c,this.resources=this._buildResourceAccessor(r,l)}addResource(t,e,n){var r,o;(r=this._uniformBindMap)[e]||(r[e]={}),(o=this._uniformBindMap[e])[n]||(o[n]=t),this.groups[e]||(this.groups[e]=new i.T,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const n={};for(const r in e){const o=e[r];Object.defineProperty(n,o.name,{get:()=>t[o.group].getResource(o.binding),set(e){t[o.group].setResource(e,o.binding)}})}return n}destroy(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];var e,n;(this.emit("destroy",this),t)&&(null===(e=this.gpuProgram)||void 0===e||e.destroy(),null===(n=this.glProgram)||void 0===n||n.destroy());this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((t=>{t.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(t){const{gpu:e,gl:n,...r}=t;let i,a;return e&&(i=s.B.from(e)),n&&(a=o.M.from(n)),new c({gpuProgram:i,glProgram:a,...r})}}},5222:(t,e,n)=>{n.d(e,{k:()=>c});var r=n(2026),o=n(801);const i=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],s=i.reduce(((t,e)=>(t[e]=!0,t)),{});function a(t,e){switch(t){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const u=class t{constructor(e,n){this._touched=0,this.uid=(0,r.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,r.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,n={...t.defaultOptions,...n},this.uniformStructures=e;const u={};for(const t in e){var c,l;const n=e[t];if(n.name=t,n.size=null!==(c=n.size)&&void 0!==c?c:1,!s[n.type])throw new Error("Uniform type ".concat(n.type," is not supported. Supported uniform types are: ").concat(i.join(", ")));null!==(l=n.value)&&void 0!==l||(n.value=a(n.type,n.size)),u[t]=n.value}this.uniforms=u,this._dirtyId=1,this.ubo=n.ubo,this.isStatic=n.isStatic,this._signature=(0,o.X)(Object.keys(u).map((t=>"".concat(t,"-").concat(e[t].type))).join("-"),"uniform-group")}update(){this._dirtyId++}};u.defaultOptions={ubo:!1,isStatic:!1};let c=u},576:(t,e,n)=>{n.d(e,{U:()=>i});const r={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},o=class t{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(t){!!(1&this.data)!==t&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(t){!!(2&this.data)!==t&&(this.data^=2)}set cullMode(t){"none"!==t?(this.culling=!0,this.clockwiseFrontFace="front"===t):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(t){!!(4&this.data)!==t&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(t){!!(8&this.data)!==t&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(t){!!(32&this.data)!==t&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(t){!!(16&this.data)!==t&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(t){this.blend="none"!==t,this._blendMode=t,this._blendModeId=r[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return"[pixi.js/core:State blendMode=".concat(this.blendMode," clockwiseFrontFace=").concat(this.clockwiseFrontFace," culling=").concat(this.culling," depthMask=").concat(this.depthMask," polygonOffset=").concat(this.polygonOffset,"]")}static for2d(){const e=new t;return e.depthTest=!1,e.blend=!0,e}};o.default2d=o.for2d();let i=o},3202:(t,e,n)=>{n.d(e,{W:()=>a});var r=n(8186),o=n(2497),i=n(6675);let s=0;const a=new class{constructor(t){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=t||{},this.enableFullScreen=!1}createTexture(t,e,n){const r=new o.v({...this.textureOptions,width:t,height:e,resolution:1,antialias:n,autoGarbageCollect:!0});return new i.g({source:r,label:"texturePool_".concat(s++)})}getOptimalTexture(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,o=arguments.length>3?arguments[3]:void 0,i=Math.ceil(t*n-1e-6),s=Math.ceil(e*n-1e-6);i=(0,r.U5)(i),s=(0,r.U5)(s);const a=(i<<17)+(s<<1)+(o?1:0);this._texturePool[a]||(this._texturePool[a]=[]);let u=this._texturePool[a].pop();return u||(u=this.createTexture(i,s,o)),u.source._resolution=n,u.source.width=i/n,u.source.height=s/n,u.source.pixelWidth=i,u.source.pixelHeight=s,u.frame.x=0,u.frame.y=0,u.frame.width=t,u.frame.height=e,u.updateUvs(),this._poolKeyHash[u.uid]=a,u}getSameSizeTexture(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=t.source;return this.getOptimalTexture(t.width,t.height,n._resolution,e)}returnTexture(t){const e=this._poolKeyHash[t.uid];this._texturePool[e].push(t)}clear(t){if(t=!1!==t)for(const e in this._texturePool){const t=this._texturePool[e];if(t)for(let e=0;e<t.length;e++)t[e].destroy(!0)}this._texturePool={}}}},801:(t,e,n)=>{n.d(e,{X:()=>i});const r=Object.create(null),o=Object.create(null);function i(t,e){let n=o[t];return void 0===n&&(void 0===r[e]&&(r[e]=1),o[t]=n=r[e]++),n}},6650:(t,e,n)=>{n.d(e,{W:()=>r});var r=(t=>(t[t.WEBGL=1]="WEBGL",t[t.WEBGPU=2]="WEBGPU",t[t.BOTH=3]="BOTH",t))(r||{})},9385:(t,e,n)=>{function r(t,e,n){const r=(t>>24&255)/255;e[n++]=(255&t)/255*r,e[n++]=(t>>8&255)/255*r,e[n++]=(t>>16&255)/255*r,e[n++]=r}n.d(e,{V:()=>r})},1669:(t,e,n)=>{n.d(e,{K:()=>r});class r{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(t,e,n,r){const o=this.renderable,i=this.texture,s=o.groupTransform,a=s.a,u=s.b,c=s.c,l=s.d,d=s.tx,f=s.ty,m=this.bounds,h=m.maxX,p=m.minX,g=m.maxY,v=m.minY,x=i.uvs,b=o.groupColorAlpha,y=r<<16|65535&this.roundPixels;t[n+0]=a*p+c*v+d,t[n+1]=l*v+u*p+f,t[n+2]=x.x0,t[n+3]=x.y0,e[n+4]=b,e[n+5]=y,t[n+6]=a*h+c*v+d,t[n+7]=l*v+u*h+f,t[n+8]=x.x1,t[n+9]=x.y1,e[n+10]=b,e[n+11]=y,t[n+12]=a*h+c*g+d,t[n+13]=l*g+u*h+f,t[n+14]=x.x2,t[n+15]=x.y2,e[n+16]=b,e[n+17]=y,t[n+18]=a*p+c*g+d,t[n+19]=l*g+u*p+f,t[n+20]=x.x3,t[n+21]=x.y3,e[n+22]=b,e[n+23]=y}packIndex(t,e,n){t[e]=n+0,t[e+1]=n+1,t[e+2]=n+2,t[e+3]=n+0,t[e+4]=n+2,t[e+5]=n+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);
//# sourceMappingURL=83.e86d40de.chunk.js.map